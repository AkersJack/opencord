import socket
import sys
import uuid
from datetime import datetime
import json
from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes
from Crypto.Cipher import AES, PKCS1_OAEP
import threading
import time
import os
import hash.hashing_methods as hashing_methods

"""
        The profile hash is either generated by a third party, an Opencord server, or the Verified Opencord Web server. 

        There might be a profile hash table so a profile can be used with multiple different servers. 
    
"""


# This class is used for communication and has all communication information
class Communication:
    def __init__(self):
        self.session_id = None  # ID of the chat session
        self.client_version = ""  # Version of the client
        self.server_version = ""  # Version of the server
        self.profile_hash = 0
        self.authorization = ""  # Pending auth to begin using the service
        self.sessionToken = ""  # Token for the session
        self.messageNumber = 0  # keeps track of the number of messages sent so far
        self.private_key = None  # Private key (used to decrypt the servers response)
        self.public_key = None  # Public key (used to encrypt the server response)
        self.symmetric_key = None  # symmetric key (sent by the server and used for the rest of the session)
        self.update_packet = False  # If it is an update packet or not
        self.sock = None  # Socket connection

        # self.check_profile_hash()

    # def check_profile_hash(self):
    #     if self.profile_hash is None:
    #         self.profile_hash = hashing_methods.generate_profile_hash(str(uuid.uuid4()))
    #         # store in system args persistently
    #         sys.argv.append(self.profile_hash)
    #
    #     else:
    #         self.profile_hash = sys.argv[1]

    def send(self, content):
        message = {
            "n": self.messageNumber,
            "time": (datetime.now()).strftime("%Y-%m-%d %H:%M:%S"),
            "content": content,
            "token": "NEED TO IMPLEMENT!",
        }

        self.messageNumber += 1
        return message

    def generateKeys(self):
        key = RSA.generate(2048)
        self.private_key = key.export_key()
        self.public_key = key.publickey().export_key()

    def decrypt(self, message):
        cipher_rsa = PKCS1_OAEP.new(self.private_key)
        # session_key = cipher_rsa.decrypt(enc_session_key)

    # Begin communication with the server 
    def begin(self):
        return {"service": 0, "client_version": self.client_version, "profile": self.profile_hash}


class Data:
    def __init__(self):
        self.server_id = ""  # Server ID
        self.server_name = ""  # Server name
        self.key = ""  # Key
        self.type = ""  # Type of communication (client to client, client to server)
        self.client_version = ""  # Version of the client
        self.client_hash = ""  # Hash of the client

    def get_data(self):
        pass

    def getChat(self, start_date, end_date):
        pass

    # Initiate the communication with the server 
    def start(self):
        pass


def update(timeout=0.5):
    while True:
        time.sleep(timeout)
        try:
            received = str(chat.sock.recv(1024), 'utf-8')
            print("\r" + received, end="")
            print("\r" + ">>> ", end="")
        except Exception as e:  # broad exception, unfavorable
            print(e)
            pass


if __name__ == "__main__":
    HOST, PORT = "localhost", 9090
    # data = " ".join(sys.argv[1:])
    chat = Communication()
    # Create a socket (SOCK_STREAM means a TCP socket)

    header = """\033[91m
    ·································································
    : _____                                                  __     :
    :/\  __`\                                               /\ \    :
    :\ \ \/\ \  _____      __    ___     ___    ___   _ __  \_\ \   :
    : \ \ \ \ \/\ '__`\  /'__`\/' _ `\  /'___\ / __`\/\`'__\/'_` \  :
    :  \ \ \_\ \ \ \L\ \/\  __//\ \/\ \/\ \__//\ \L\ \ \ \//\ \L\ \ :
    :   \ \_____\ \ ,__/\ \____\ \_\ \_\ \____\ \____/\ \_\\ \___,_\:
    :    \/_____/\ \ \/  \/____/\/_/\/_/\/____/\/___/  \/_/ \/__,_ /:
    :             \ \_\                                             :
    :              \/_/                                             :
    ·································································
    """ + "\u001b[0m" + '\n'

    print(header)

    # This won't open until everything is validated however we are going to do it like this for now

    # Auto update the chat
    update = threading.Thread(target=update, daemon=True)

    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        update.start()
        # Connect to server and send data
        data = None
        sock.connect((HOST, PORT))
        hi_packet = json.dumps(chat.begin()).encode('utf-8')  # send in the starter packet
        sock.sendall(hi_packet)  # Say hi to the server and authorize connection
        chat.sock = sock
        while data != "/exit":
            # print("\r>>> ", end="")
            data = input()
            if data == "/exit":
                break
            d = chat.send(data)

            encoded_data = (json.dumps(d)).encode('utf-8')
            # sock.sendall(bytes(d + '\n', 'utf-8'))
            sock.sendall(encoded_data)

            # received = str(sock.recv(1024), 'utf-8')
            # print(received)

            # Receive data from the server and shut down

    print(f"Sent: {data}")
    # print(f"Received: {received}")
